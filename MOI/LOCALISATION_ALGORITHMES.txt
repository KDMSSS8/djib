â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ¯ LOCALISATION DES ALGORITHMES - LIGNES DE CODE ESSENTIELLES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‚ Dossier: c:\Users\Djibril\OneDrive\Bureau\PRJ4\MOI\controllers\

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1ï¸âƒ£  FORCE BRUTE - brute_force_resolver.py (44 lignes totales)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ Classe: BruteForceResolver (Ligne 6)
ğŸ“ MÃ©thode solve(): Ligne 14

ğŸ”‘ LA BOUCLE PRINCIPALE (Lignes 19-32):

    Ligne 19 : for r in range(len(self.actions) + 1):
    Ligne 20 :     for combination in combinations(self.actions, r):  â­ 2^n combos
    Ligne 21 :         self.iterations += 1
    Ligne 22 :         portfolio = Portfolio(list(combination))
    Ligne 23 :         if portfolio.is_valid(self.max_budget):        â­ VÃ©rifie budget
    Ligne 24 :             current_profit = portfolio.get_total_profit()
    Ligne 25 :             if current_profit > best_profit:           â­ Garde meilleur
    Ligne 26 :                 best_profit = current_profit
    Ligne 27 :                 best_portfolio = portfolio

â±ï¸  ComplexitÃ©: O(2^n) = LENT
âš¡ n=25: 109 secondes
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

2ï¸âƒ£  PROGRAMMATION DYNAMIQUE - dynamic_programming_resolver.py (49 lignes totales)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ Classe: DynamicProgrammingResolver (Ligne 6)
ğŸ“ MÃ©thode solve(): Ligne 14

ğŸ”‘ Ã‰TAPE 1 - CRÃ‰ER TABLE DP (Lignes 18-19):

    Ligne 18 : # Table DP: dp[i][w] = profit max avec i actions et budget w
    Ligne 19 : dp = [[0 for _ in range(self.max_budget + 1)] for _ in range(n + 1)]

ğŸ”‘ Ã‰TAPE 2 - REMPLIR TABLE (Lignes 21-28):

    Ligne 21 : for i in range(1, n + 1):
    Ligne 22 :     action = self.actions[i - 1]
    Ligne 23 :     cost = int(action.cost)
    Ligne 24 :     profit = action.get_profit()
    Ligne 25 :     for w in range(self.max_budget + 1):
    Ligne 26 :         dp[i][w] = dp[i - 1][w]                      â­ Ne pas prendre
    Ligne 27 :         if cost <= w:
    Ligne 28 :             dp[i][w] = max(dp[i][w], dp[i - 1][w - cost] + profit)  â­ Ou prendre

ğŸ”‘ Ã‰TAPE 3 - BACKTRACKING (Lignes 30-38):

    Ligne 30 : selected_actions = []
    Ligne 31 : w = self.max_budget
    Ligne 32 : for i in range(n, 0, -1):
    Ligne 33 :     if dp[i][w] != dp[i - 1][w]:                    â­ Action prise?
    Ligne 34 :         selected_actions.append(self.actions[i - 1])
    Ligne 35 :         w -= int(self.actions[i - 1].cost)
    Ligne 36 : selected_actions.reverse()

â±ï¸  ComplexitÃ©: O(n Ã— W) = RAPIDE âœ…
âš¡ n=25: 3.7 secondes
ğŸš€ SPEEDUP: 29.5Ã— plus rapide
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š TABLEAU COMPARATIF

                    FORCE BRUTE             PROGRAMMATION DYNAMIQUE
Fichier             brute_force_            dynamic_programming_
                    resolver.py             resolver.py

Lignes totales      44                      49

Classe              BruteForceResolver      DynamicProgrammingResolver

MÃ©thode solve()     Ligne 14                Ligne 14

Boucle principal    Lignes 19-20            Lignes 21-28
(remplissage)

ComplexitÃ©          O(2^n)                  O(n Ã— W)

Performance         109 sec (n=25)          3.7 sec (n=25)

Speedup             LENT âŒ                 29.5Ã— RAPIDE âœ…

UtilitÃ©             Petit n (<20)           PRODUCTION â­

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ COMPRENDRE LES ALGORITHMES

FORCE BRUTE:
  â”œâ”€ Ligne 20: combinations() gÃ©nÃ¨re C(n,0), C(n,1), ..., C(n,n)
  â”œâ”€ RÃ©sultat: 2^n combinaisons testÃ©es
  â”œâ”€ Ligne 23: Filtre les valides (respectent budget)
  â”œâ”€ Lignes 25-27: Garde la meilleure
  â””â”€ AVANTAGE: Garantit solution optimale
     INCONVÃ‰NIENT: TrÃ¨s lent quand n augmente

PROGRAMMATION DYNAMIQUE:
  â”œâ”€ Ligne 19: Table [n+1][W+1] crÃ©Ã©e (taille fixe)
  â”œâ”€ Lignes 21-28: Remplit la table ONCE
  â”œâ”€ Ligne 26: Option "ne pas prendre" = ligne prÃ©cÃ©dente
  â”œâ”€ Ligne 28: Option "prendre" = profit prÃ©cÃ©dent + profit actuel
  â”œâ”€ Lignes 32-35: Backtrack pour trouver quelles actions prendre
  â””â”€ AVANTAGE: Rapide, optimal, scalable
     INCONVÃ‰NIENT: Plus complexe Ã  comprendre

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ’¡ POINTS CLÃ‰S

Force Brute (Ligne 20):
    for combination in combinations(self.actions, r):
    â””â”€â†’ C'EST ICI que Ã§a teste 2^n possibilitÃ©s

Programmation Dynamique (Ligne 28):
    dp[i][w] = max(dp[i][w], dp[i - 1][w - cost] + profit)
    â””â”€â†’ C'EST ICI que se fait la logique optimale (choix ou pas)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
